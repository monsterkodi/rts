
Path = require '../track/path'
Engine = require './engine'
Boxcar = require './boxcar'

function Train
    
    @numTrains: 0

    @: (@cfg) ->
        
        Train.numTrains++
        @name       = (@cfg.name ? "T") + Train.numTrains
        @path       = new Path @
        @speed      = @cfg.speed ? 1
        @topSpeed   = @speed
        @advanceFactor = 1
        @cars       = []
        
        @mesh       = new Mesh Geom.cylinder(radius:0.5, height:0.2), Materials.train.window
        @mesh.train = @
        @mesh.visible = false
        world.addObject @mesh
        
    del: ->
        
        for car in @cars
            car.del()
        @cars = []
        world.removeObject @mesh
        
    isOneWay: -> return not (@cars[-1] instanceof Engine)
    
    reverse: ->
        
        if not @isOneWay()
        
            @path.delta = @path.getLength() - @tailDelta()
            @path.reverse()
            head = @cars.shift()
            tail = @cars.pop()
            @cars.unshift tail
            @cars.push head
            
        else
            warn 'cant reverse oneWay train!'
        
    #  0000000   0000000   00000000   
    # 000       000   000  000   000  
    # 000       000000000  0000000    
    # 000       000   000  000   000  
    #  0000000  000   000  000   000  
    
    addCar: (car) ->
        
        @cars.push car
        car.index = @cars.length-1
        car.name = @name + ".#{car.constructor.name[0]}#{car.index}"
        car.mesh.name = car.name
        car
        
    boxcars: -> @cars.filter (c) -> c instanceof Boxcar
        
    setColor: (color) ->
        
        for car in @cars
            car.setColor color
            
    setColorByName: (name) ->
        
        for car in @cars
            car.setColorByName name
            
    addPreview: ->
        
        @preview = @cars[0].mesh.clone()
        @preview.material = Materials.misc.transparent
        for c in @preview.children
            c.material = Materials.misc.transparent
        world.scene.add @preview
        
    block:   -> @speed = 0
    unblock: -> @speed = @topSpeed
    
    carDelta:   (car) -> @path?.normDelta @path.delta-4.2*(car.index)
    tailDelta:        -> @path?.normDelta @path.delta-4.2*(@cars.length-1)
    tailTrack:        -> @path?.trackAtDelta @tailDelta()
    prevTailTrack:    -> @path?.tracks[@path.normIndex @path.indexAtDelta(@tailDelta())-1]
    tailPrevDistance: -> @path?.prevDistance @tailDelta()
                
    update: (delta, timeSum) ->
        
        return if not @path

        advance = delta * @speed
        
        advance = world.traffic.allowTrainAdvance @, advance
        
        @path.advance advance
                
        for car, index in @cars
            car.update delta, timeSum, @
            car.moveToPathDelta @path, -4.2*index
            
        @mesh.position.copy @cars[0].mesh.position
        @mesh.position.z += 1.8
        @mesh.material = @cars[0].mesh.children[1].material
        
        if @preview
            #@path.moveMesh @preview, 8
            # log @path.delta, @path.currentIndex(), @path.nextNode().name
            @preview.position.copy @path.nextNode().position
            # @preview.needsUpdate = true
                        
module.exports = Train
