###
000000000  00000000    0000000   00000000  00000000  000   0000000
   000     000   000  000   000  000       000       000  000     
   000     0000000    000000000  000000    000000    000  000     
   000     000   000  000   000  000       000       000  000     
   000     000   000  000   000  000       000       000   0000000
###

HEAD_DISTANCE    = 12
TAIL_DISTANCE    = 8
REAREND_DISTANCE = 6

function Traffic

    @: ->
        
        @trains = []
    
    addTrain: (train) -> @trains.push train
        
    simulate: (scaledDelta, timeSum) ->
        
        @nodeSignals()
        
    nodeSignals: ->
        
        for train in @trains
            path = train.path
            p = path.nextDistance()
            if p < HEAD_DISTANCE                         # train is close to target node
                n = path.nextNode()
                if n.train != train                      # if node is not owned by train
                    if not n.train                       #      if node not occupied
                        n.setTrain train                 #          train occupies node 
                    else 
                        if train not in n.blockedTrains  # if train not alreay blocked by node
                            if train.path.currentTrack()  != n.train.tailTrack() and 
                                train.path.currentTrack() != n.train.prevTailTrack() and
                                train.path.nextTrack()    != n.train.tailTrack()
                                n.block train            #      train gets blocked
                            else 
                                if train.path.currentTrack() == n.train.prevTailTrack()
                                    n.setTrain train     # train is the new occupant
            
            tailDelta = train.tailDelta()
            s = path.prevDistance tailDelta
            if s > TAIL_DISTANCE
                n = path.prevNode tailDelta
                if n.train == train
                    n.unblock()
                                    
    allowTrainAdvance: (train, advance) ->
        
        delta = train.path.delta+advance
        track = train.path.trackAtDelta delta
        for other in @trains
            continue if other == train
            if other.tailTrack() == track
                trainToOther = other.tailPrevDistance() - train.path.prevDistance(delta)
                if trainToOther >= 0 and trainToOther < REAREND_DISTANCE
                    return 0
            else if other.prevTailTrack() == track
                trainToOther = other.tailPrevDistance() + train.path.nextDistance(delta)
                if trainToOther >= 0 and trainToOther < REAREND_DISTANCE
                    return 0
        advance

module.exports = Traffic
