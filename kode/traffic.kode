###
000000000  00000000    0000000   00000000  00000000  000   0000000
   000     000   000  000   000  000       000       000  000     
   000     0000000    000000000  000000    000000    000  000     
   000     000   000  000   000  000       000       000  000     
   000     000   000  000   000  000       000       000   0000000
###

NODE_DISTANCE    = 9
REAREND_DISTANCE = 5

function Traffic

    @: ->
        
        @nodes = []
        @trains = []
        @tracks = []
    
    simulate: (scaledDelta, timeSum) ->
        
        @nodeSignals()
        
    nodeSignals: ->
        
        for train in @trains
            path = train.path
            p = path.nextDistance()
            if p < NODE_DISTANCE                         # train is close to target node
                n = path.nextNode()
                if n.train != train                      # if node is not owned by train
                    if not n.train                       #      if node not occupied
                        n.setTrain train                 #          train occupies node 
                    else 
                        if train not in n.blockedTrains  # if train not alreay blocked by node
                            if train.path.currentTrack()  != n.train.path.currentTrack() and 
                                train.path.currentTrack() != n.train.path.prevTrack() and
                                train.path.nextTrack()    != n.train.path.currentTrack()
                                n.block train            #      train gets blocked
                            else 
                                if n.train.path.prevTrack() == train.path.currentTrack()
                                    n.setTrain train     # train is the new occupant
            
            tailDelta = train.tailDelta()
            s = path.prevDistanceAtDelta tailDelta
            if s > NODE_DISTANCE
                n = path.prevNodeAtDelta tailDelta
                if n.train == train
                    # log 'unblocks' n.name, train.name
                    n.unblock()
                            
    addNode:  (node)  -> @nodes.push  node
    addTrain: (train) -> @trains.push train
    addTrack: (track) -> @tracks.push track
        
    allowTrainAdvance: (train, advance) ->
        
        delta = train.path.delta+advance
        track = train.path.trackAtDelta(delta)
        for other in @trains
            continue if other == train
            if other.path.currentTrack() == track
                trainToOther = other.path.prevDistance() - train.path.prevDistanceAtDelta(delta)
                if trainToOther >= 0 and trainToOther < REAREND_DISTANCE
                    # log 'rearend!' train.name, train.path.prevDistanceAtDelta(delta)
                    # log '   other' other.name, other.path.prevDistance()
                    # train.speed = clamp 0 train.speed, other.speed
                    return 0
            else if other.path.prevTrack() == track
                trainToOther = other.path.prevDistance() + train.path.nextDistanceAtDelta(delta)
                if trainToOther >= 0 and trainToOther < REAREND_DISTANCE
                    # log 'rearend!2!' train.name, train.path.prevDistanceAtDelta(delta)
                    # log '   other' other.name, other.path.prevDistance()
                    # train.speed = clamp 0 train.speed, other.speed
                    return 0
                
        advance

module.exports = Traffic
