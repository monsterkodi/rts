###
000000000  00000000    0000000    0000000  000   000
   000     000   000  000   000  000       000  000 
   000     0000000    000000000  000       0000000  
   000     000   000  000   000  000       000  000 
   000     000   000  000   000   0000000  000   000
###

Rail = require './rail'
CurveCtrl = require '../track/curvectrl'

function Track

    @id: 0

    @: (points, @name) ->
        
        Track.id++
        
        @name ?= "t#{Track.id}"
        
        @curve = new CurvePath
        @node  = []
        @ctrls = []
        
        curveNum = Math.floor points.length / 4
        
        for index in 0...curveNum
            p = points.slice index*4, index*4+4
            @curve.add new CubicBezierCurve3 p[0], p[1], p[2], p[3]
        
        for index in 0...curveNum
            @ctrls.push new CurveCtrl @, index
                    
        @createRail()     
        
        @mesh.track  = @
        @mesh.toSave = @toSave
        @mesh.toSave.key = 'tracks'
        
    toSave: =>

        fix = (p) -> x:p.x.toFixed(1), y:p.y.toFixed(1), z:p.z.toFixed(1)
        ctrl = []
        for i in 0...@curve.curves.length
            ctrl.push fix @curve.curves[i].v1
            ctrl.push fix @curve.curves[i].v2
            if i < @curve.curves.length-1
                ctrl.push fix @curve.curves[i].v3
        
        name: @name
        node: @node.map (n) -> n.name
        ctrl: ctrl
        
    del: ->
        
        if @mesh
            post.emit 'delTrack' @
            
            @node[0]?.removeTrack @
            @node[1]?.removeTrack @
            
            world.removePickable @mesh
            world.removeObject @mesh
            for ctrl in @ctrls
                ctrl.del()
            @mesh?.removeFromParent()
            delete @curve
            delete @node
            delete @ctrls
            delete @mesh
            delete @rail
            
    # 00     00   0000000   000   000   0000000  00000000    
    # 000   000  000   000  000   000  000       000         
    # 000000000  000   000  000   000  0000000   0000000     
    # 000 0 000  000   000  000   000       000  000         
    # 000   000   0000000    0000000   0000000   00000000    
            
    onEnter: -> 
        
        world.cursorTrack = @
        
    onLeave: -> 
        
        if world.cursorTrack == @
            delete world.cursorTrack
            
    onDoubleClick: ->
        
        log 'split track!'
        
    # 00     00   0000000   000   000  00000000  0000000    
    # 000   000  000   000  000   000  000       000   000  
    # 000000000  000   000   000 000   0000000   000   000  
    # 000 0 000  000   000     000     000       000   000  
    # 000   000   0000000       0      00000000  0000000    
    
    ctrlMoved: =>
        
        @curve.updateArcLengths()
        @createRail()
                
    nodeRotated: (n) ->
        
        dir = n.getDir()
        if @ not in n.outTracks
            dir.negate()
        
        if n == @node[0]
            @ctrls[0].rotateStart dir
        else if n == @node[1]
            @ctrls[-1].rotateEnd dir
        
        @curve.updateArcLengths()
        @createRail()

    nodeMoved: (n) ->
        
        if n == @node[0]
            @ctrls[0].moveStartTo n.getPos()
        else
            @ctrls[-1].moveEndTo n.getPos()
        
        @curve.updateArcLengths()
        @createRail()
        
    # 00000000    0000000   000  000      
    # 000   000  000   000  000  000      
    # 0000000    000000000  000  000      
    # 000   000  000   000  000  000      
    # 000   000  000   000  000  0000000  
    
    createRail: ->
        
        @rail = new Rail @curve, 100
                
        if @mesh
            @mesh.geometry = @rail
        else
            @createMesh()                
            
        @curve.getPointAt 0.25, @label.position
        @label.position.z = 0.36
        
        @curve.getTangentAt 0.5, Vector.tmp
        @label.quaternion.copy Quaternion.unitVectors Vector.unitY, Vector.tmp
        
    createMesh: ->    
    
        @mesh = new Mesh @rail, Materials.track.rail
        @mesh.name = @name
        @mesh.setShadow()
        @mesh.handler = @
        
        @label = world.addLabel text:@name, size:0.5, mono:true
        @mesh.add @label
        
        world.addObject @mesh
        world.addPickable @mesh
                
    nodeOpposite: (node) ->
        
        if      
            node == @node[0] ➜ return @node[1]
            node == @node[1] ➜ return @node[0]
                             ➜ log 'nodeOpposite.dafuk?'
                             
    getPoints: ->
        
        points = []
        for curve in @curve.curves
            points = points.concat [curve.v0, curve.v1, curve.v2, curve.v3]
        points

    getCtrlPoints: (includeLast) ->
        
        points = []
        for curve in @curve.curves
            points = points.concat [curve.v1, curve.v2, curve.v3]
        points.pop() if not includeLast
        points
        
    getPointsFromNode: (node) ->
        
        points = @getPoints()
        if node == @node[1] ➜ points.reverse()
        points

    getCtrlPointsFromNode: (node, includeLast) ->
        
        points = @getCtrlPoints includeLast
        if node == @node[1] ➜ points.reverse()
        points
        
module.exports = Track
