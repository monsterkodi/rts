###
000000000  00000000    0000000    0000000  000   000
   000     000   000  000   000  000       000  000 
   000     0000000    000000000  000       0000000  
   000     000   000  000   000  000       000  000 
   000     000   000  000   000   0000000  000   000
###

Rail = require './rail'
CurveCtrl = require '../track/curvectrl'

function Track

    @: (points, @name) ->
        
        @node = []
        
        @curve = new CurvePath
        
        @ctrls = []
        
        segnum = Math.floor points.length / 4
        
        log segnum
        
        for pi in 0...segnum
            c = new CubicBezierCurve3 points[pi*4+0], points[pi*4+1], points[pi*4+2], points[pi*4+3]
            @curve.add c
            @ctrls.push new CurveCtrl c, @curve, pi, @ctrlMoved
                    
        @createRail()        
        
    del: ->
        
        world.removePickable @mesh
        world.removeObject @mesh
        for ctrl in @ctrls
            ctrl.del()
        @mesh?.removeFromParent()
        delete @curve
        delete @node
        delete @ctrls
        delete @mesh
        delete @rail
        
    ctrlMoved: =>
        
        @curve.updateArcLengths()
        @createRail()
                
    nodeRotated: (n) ->
        
        if @ in n.outTracks
            dir = vec n.dir
        else
            dir = vec(n.dir).negated()
        
        if n == @node[0]
            @ctrls[0].rotateStart dir
        else if n == @node[1]
            @ctrls[-1].rotateEnd dir
        
        @curve.updateArcLengths()
        @createRail()

    nodeMoved: (n) ->
        
        if n == @node[0]
            @ctrls[0].moveStartTo n.position
        else
            @ctrls[-1].moveEndTo n.position
        
        @curve.updateArcLengths()
        @createRail()
        
    createRail: ->
        
        @rail = new Rail @curve, 100
        if @mesh
            @mesh.geometry = @rail
        else
            @createMesh()                
        
    createMesh: ->    
    
        @mesh = new Mesh @rail, Materials.train.rail
        @mesh.name = @name
        @mesh.castShadow = true
        @mesh.receiveShadow = true
        @mesh.handler = @
        
        world.addObject @mesh
        world.addPickable @mesh
        
    onDoubleClick: ->
        
        log 'split track!'
        
    nodeOpposite: (node) ->
        
        if      
            node == @node[0] ➜ return @node[1]
            node == @node[1] ➜ return @node[0]
                             ➜ log 'nodeOpposite.dafuk?'
                             
    getPoints: ->
        
        points = []
        for curve in @curve.curves
            points = points.concat [curve.v0, curve.v1, curve.v2, curve.v3]
        points
        
    getPointsFromNode: (node) ->
        
        points = @getPoints()
        log points
        if node == @node[1] ➜ points.reverse()
        points

module.exports = Track
