###
00000000    0000000   000000000  000   000
000   000  000   000     000     000   000
00000000   000000000     000     000000000
000        000   000     000     000   000
000        000   000     000     000   000
###

function Path

    @: (@train) ->
        
        @name   = @train.name + '.path'
        log '+Path' @name
        @delta  = 0
        @tracks = []
        @nodes  = []
        @revers = []
        
        post.on 'delTrack' @onDelTrack
        post.on 'delNode'  @onDelNode
        
    del: ->
        log '-Path' @name
        @train.path = null
        
    updateLoop: ->
       
        ts = @tracks[0]
        te = @tracks[-1]
        @isLoop = ts.node[0] == te.node[1]
        
    onDelTrack: (track) =>
        
        while (i = @tracks.indexOf track) >= 0
            @tracks.splice i, 1
            @revers.splice i, 1
            
        # log 'deltrack' @name, track.name, @tracks.length, @revers.length, @nodes.length
        
        if empty @tracks
            @del()
        else
            @updateLoop()
            
    onDelNode: (node) =>
        
        while (i = @nodes.indexOf node) >= 0
            @nodes.splice i, 1
            
    addTrackNode: (track, node) ->
        
        @nodes.push node
        @tracks.push track
        @revers.push track.node[0] == node
        
        @updateLoop()
                           
    getLength: -> 
        
        cd = 0
        for ti in 0...@tracks.length
            if @tracks[ti].curve
                cd += @tracks[ti].curve.getLength()
            else
                log @name, ti, @tracks[ti]
        cd
                
    deltaAtIndex: (index) ->
        index = @normIndex index
        cd = 0
        for ti in 0...index
            if @tracks[ti].curve
                cd += @tracks[ti].curve.getLength()
            else
                log @name, ti, @tracks[ti]
        cd
            
    indexAtDelta: (d) ->
        nd = @normDelta d
        cd = 0
        for t,i in @tracks
            if t.curve
                cd += t.curve.getLength()
            else
                log @name, i, t
            if cd >= nd
                return i
        log 'dafuk?' @name, d, nd, cd
        
    nodeAtDelta:  (d) -> @nodes[@indexAtDelta d]
    curveAtDelta: (d) -> @tracks[@indexAtDelta d].curve
    posAtDelta:   (d) ->
        d = @normDelta d
        di = @indexAtDelta d
        restDelta = d - @deltaAtIndex di
        p = restDelta / @tracks[di].curve.getLength()
        if @revers[di]
            p = 1 - p
        p
                
    currentIndex: -> @indexAtDelta @delta
    
    nextNode: (d=@delta) -> @nodes[@indexAtDelta(d)]
    prevNode: (d=@delta) -> @nodes[@normIndex @indexAtDelta(d)-1]
    
    prevTrack:    -> @tracks[@normIndex @currentIndex()-1]
    currentTrack: -> @tracks[@currentIndex()]
    nextTrack:    -> @tracks[@normIndex @currentIndex()+1]
    
    trackAtDelta: (d) -> @tracks[@normIndex @indexAtDelta d]
        
    currentCurve: -> @currentTrack().curve
    currentPos:   -> @posAtDelta @delta
    
    nextDistance: (d=@delta) -> @normDelta @deltaAtIndex(@indexAtDelta(d)+1) - d
    prevDistance: (d=@delta) -> @normDelta d - @deltaAtIndex(@indexAtDelta(d))
            
    advance: (delta) ->
        
        @delta = @normDelta @delta+delta
    
    getPoint: (point, offset=0) ->
        d = @delta+offset
        @curveAtDelta(d).getPointAt @posAtDelta(d), point

    getTangent: (point, offset=0) ->
        d = @delta+offset
        if @revers[@indexAtDelta d]
            @curveAtDelta(d).getTangentAt @posAtDelta(d), point
            point.multiplyScalar -1
        else
            @curveAtDelta(d).getTangentAt @posAtDelta(d), point

    moveMesh: (mesh, offset) ->
        
        @getPoint mesh.position, offset
        @getTangent Vector.tmp, offset
        Vector.tmp.add mesh.position 
        mesh.up.set 0 0 1
        mesh.lookAt Vector.tmp
        
    normDelta: (d) ->
        
        length = @getLength()
        return 0 if not length
        (d+10*length) % length
        
    normIndex: (i) ->
         
        length = @tracks.length
        return 0 if not length
        (i+10*length) % length
            
module.exports = Path
