###
000   000   0000000   0000000    00000000
0000  000  000   000  000   000  000     
000 0 000  000   000  000   000  0000000 
000  0000  000   000  000   000  000     
000   000   0000000   0000000    00000000
###

CurveCtrl = require './curvectrl'
Compass   = require './compass'

function Node

    @numNodes: 0

    @: (point, @name) ->
        
        Node.numNodes++
        
        @name = "n#{Node.numNodes}" if not @name
        
        @position = vec point
        @dir      = vec 0 1 0
        @up       = vec 0 0 1
        
        @inTracks  = []
        @outTracks = []
        @blockedTrains = []
        @blocks = []
        @gizmo = {}
        
        geom = new CylinderGeometry 0.7 0.7 0.71 32
        geom.rotateX Math.PI/2
        @center = new Mesh geom, Materials.ctrl.curve
        @center.name = 'node.center'
        # @center.handler = @
        # @center.onDrag  = @onDrag
        @center.onHover = @onHover
        
        geom = new BoxGeometry 1 1 1
        
        @outMesh = new Mesh geom, Materials.ctrl.start
        @outMesh.position.add @dir.scaled 2
        @outMesh.onDrag = @onOutDrag
        @outMesh.onDragDone = @onDragDone
        
        @inMesh = new Mesh geom, Materials.ctrl.start
        @inMesh.position.add @dir.negated().scale 2
        @inMesh.onDrag = @onInDrag
        @inMesh.onDragDone = @onDragDone
        
        @group = new Group
        @group.name = @name
        @group.add @center
        @group.add @inMesh
        @group.add @outMesh
        @group.position.copy @position
        
        world.addPickable @group
        
        @rotate 0
        
    del: ->
        
        world.hideCompass @
        @group.removeFromParent()
        world.removePickable @group
        delete @group
        
    compassCenterDoubleClicked: =>
        
        if @inTracks.length == 1 and @outTracks.length == 1
            log 'convert to ctrl'
            post.emit 'convertNodeToCtrl' @
        
    onHover: => world.showCompass @, @position, @dir
        
    # 0000000    00000000    0000000    0000000   
    # 000   000  000   000  000   000  000        
    # 000   000  0000000    000000000  000  0000  
    # 000   000  000   000  000   000  000   000  
    # 0000000    000   000  000   000   0000000   
    
    startDrag: (tracks) ->
        
        dir = vec @dir
        if tracks == @inTracks
            dir.negate()
        
        n1 = @
        n2 = world.addNode @position.plus dir
        
        n2.setDir dir
        
        c1 = dir.clone().scale( 5).add n1.position
        c2 = dir.clone().scale(-5).add n2.position
        t = world.addTrack n1, n2, [c1, c2]
                
        t.node[0] = n1
        t.node[1] = n2
        
        tracks.push t
        n2.inTracks.push t
                        
        @dragTrack = t
        
    onInDrag: (ray, hit) =>
        
        if not @dragTrack
            @startDrag @inTracks
            
        @moveInOutDrag ray, hit
                    
    onOutDrag: (ray, hit) =>
        
        if not @dragTrack
            @startDrag @outTracks

        @moveInOutDrag ray, hit
            
    moveInOutDrag: (ray, hit) ->
        
        dragNode = @dragTrack.node[1]
            
        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, hit.mesh.getWorldPosition(Vector.tmp)
        ray.intersectPlane plane, dragNode.position
        dragNode.position.round()
        dragNode.group.position.copy dragNode.position
        @dragTrack.nodeMoved dragNode
        
    onDragDone: =>
        
        delete @dragTrack
            
    onDrag: (ray, hit) =>

        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, hit.mesh.getWorldPosition(Vector.tmp)
        ray.intersectPlane plane, @position
        @position.round()
        @setPosition @position
        
    compassMoved: (point) => @setPosition point
        
    setPosition: (point) ->
        
        @position.copy point
        @group.position.copy @position
        
        for track in @outTracks
            track.nodeMoved @
        for track in @inTracks
            track.nodeMoved @
        
        for i in 0...@blockedTrains.length
            
            block = @blocks[i]
            train = @blockedTrains[i]
            train.path.getPoint block.position, 3
        
    # 00000000    0000000   000000000   0000000   000000000  00000000  
    # 000   000  000   000     000     000   000     000     000       
    # 0000000    000   000     000     000000000     000     0000000   
    # 000   000  000   000     000     000   000     000     000       
    # 000   000   0000000      000     000   000     000     00000000  
    
    onRotate: (ray, hit, downRay, lastRay) =>

        point = vec()
        hit.mesh.getWorldPosition point
        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, point
        lastRay.intersectPlane plane, Vector.tmp
        ray.intersectPlane plane, Vector.tmp2
        
        Vector.tmp.sub point
        Vector.tmp2.sub point
        angle = @dir.angle(Vector.tmp2)-@dir.angle(Vector.tmp)
        if angle
            @rotate Math.sign(@dir.crossed(@up).dot Vector.tmp) * -angle
            
    rotate: (degree) ->

        quat = Quaternion.axisAngle @up, degree
        dir = @dir.clone()
        dir.applyQuaternion quat
        @setDir dir
        
    compassRotated: (dir) => @setDir dir
        
    setDir: (dir) ->
        
        @dir.copy dir
        log @dir
        quat = Quaternion.unitVectors Vector.unitY, dir
        @group.quaternion.copy quat
        
        for track in @outTracks
            track.nodeRotated @
        for track in @inTracks
            track.nodeRotated @
        
    # 000000000  00000000    0000000   000  000   000  
    #    000     000   000  000   000  000  0000  000  
    #    000     0000000    000000000  000  000 0 000  
    #    000     000   000  000   000  000  000  0000  
    #    000     000   000  000   000  000  000   000  
    
    setTrain: (@train) ->
        
        if @train 
            if not @nodeBox
                c1 = new CylinderGeometry 0.25 0.25 1 16
                c1.rotateX Math.PI/2
                c2 = new CylinderGeometry 0.25 0.25 1.6 16
                c2.rotateZ Math.PI/2
                geom = THREE.BufferGeometryUtils.mergeBufferGeometries [c1, c2]
                @nodeBox = new Mesh geom, @train.cars[0].mesh.material
                @group.add @nodeBox
            @nodeBox.material = @train.cars[0].mesh.material
            for block in @blocks
                block.material = @nodeBox.material
        
    # 0000000    000       0000000    0000000  000   000  
    # 000   000  000      000   000  000       000  000   
    # 0000000    000      000   000  000       0000000    
    # 000   000  000      000   000  000       000  000   
    # 0000000    0000000   0000000    0000000  000   000  
    
    block: (train) ->
        
        @blockedTrains.push train
        train.block()
        
        geom = THREE.BufferGeometryUtils.mergeBufferGeometries [new BoxGeometry(0.5 1 0.5), new BoxGeometry(1 0.5 0.5)]
        
        mesh = new Mesh geom, @train.cars[0].mesh.material
        train.path.getPoint mesh.position, 3
        train.path.getTangent Vector.tmp, 3
        Vector.tmp.add mesh.position
        mesh.lookAt Vector.tmp
        world.addObject mesh
        @blocks.push mesh
        
    unblock: ->
        
        @setTrain null
        
        for t in @blockedTrains
            t.unblock()            
        
        for block in @blocks
            world.removeObject block
        
        @nodeBox.removeFromParent()
        delete @nodeBox
        @blockedTrains = []
        @blocks = []
        
    # 000000000  00000000    0000000    0000000  000   000  
    #    000     000   000  000   000  000       000  000   
    #    000     0000000    000000000  000       0000000    
    #    000     000   000  000   000  000       000  000   
    #    000     000   000  000   000   0000000  000   000  
    
    removeTrack: (track) ->
        
        tracks = @siblingTracks track
        tracks.splice tracks.indexOf(track), 1
        track.del()
        
    siblingTracks: (track) ->
        
        if 
            track in @inTracks  ➜ @inTracks
            track in @outTracks ➜ @outTracks
                                ➜ log 'no siblingTrack' 
        
module.exports = Node
