###
000   000   0000000   0000000    00000000
0000  000  000   000  000   000  000     
000 0 000  000   000  000   000  0000000 
000  0000  000   000  000   000  000     
000   000   0000000   0000000    00000000
###

CurveCtrl = require '../track/curvectrl'

function Node

    @: (point, @name) ->
        
        @position = vec point
        @dir      = vec 0 1 0
        @up       = vec 0 0 1
        
        @inTracks  = []
        @outTracks = []
        @blockedTrains = []
        @blocks = []
        @gizmo = {}
        
        geom = new CylinderGeometry 0.7 0.7 0.71 32
        geom.rotateX Math.PI/2
        @gizmo.center = new Mesh geom, Materials.ctrl.curve
        @gizmo.center.onDrag = @onDrag
        @gizmo.center.name = 'node.center'
        @gizmo.center.handler = @
        @gizmo.center.onHover = @onHover

        geom = new CylinderGeometry 1.5 1.5 0.4 32
        geom.rotateX Math.PI/2
        @gizmo.tangent = new Mesh geom, Materials.ctrl.curve #Materials.node.gizmo.tangent
        @gizmo.tangent.onDrag = @onRotate
        @gizmo.tangent.name = 'node.tangent'
        @gizmo.tangent.node = @
        @gizmo.tangent.visible = false
        
        g1 = new CylinderGeometry 0.33 0.33 0.71*1.2 24
        g1.rotateX Math.PI/2
        g1.translate 0 1.16 0
        g2 = new CylinderGeometry 0.33 0.33 0.71*1.2 24
        g2.rotateX Math.PI/2
        g2.translate 0 -1.16 0
        geom = merge g1, g2
        dotMesh = new Mesh geom, Materials.ctrl.start
        dotMesh.onDrag = @onRotate        
        dotMesh.name = 'node.tangent'
        @gizmo.tangent.add dotMesh
        
        geom = new BoxGeometry 1 1 1
        outMesh = new Mesh geom, Materials.ctrl.start
        outMesh.position.add @dir.scaled 2
        outMesh.onDrag = @onOutDrag
        outMesh.onDragDone = @onDragDone
        inMesh = new Mesh geom, Materials.ctrl.start
        inMesh.position.add @dir.negated().scale 2
        inMesh.onDrag = @onInDrag
        inMesh.onDragDone = @onDragDone
        
        @gizmo.tangent.add outMesh
        @gizmo.tangent.add inMesh
        
        @group = new Group
        @group.add @gizmo.center
        @group.add @gizmo.tangent
        @group.position.copy @position
        
        world.addPickable @group
        
        @rotate 0
        
    del: ->
        
        Node.clearActive()
        @group.removeFromParent()
        world.removePickable @group
        delete @group
        
    onDoubleClick: (ray, hit) =>
        
        if @inTracks.length == 1 and @outTracks.length == 1
            log 'convert to ctrl'
            post.emit 'convertNodeToCtrl' @
        
    onHover: =>
        
        if Node.activeNode != @
            if Node.activeNode
                Node.activeNode.deactivate()
            Node.activeNode = @
            CurveCtrl.clearActive()
            @activate()
        
    #  0000000    0000000  000000000  000  000   000  00000000  
    # 000   000  000          000     000  000   000  000       
    # 000000000  000          000     000   000 000   0000000   
    # 000   000  000          000     000     000     000       
    # 000   000   0000000     000     000      0      00000000  
    
    @clearActive: ->
        
        if Node.activeNode
            Node.activeNode.deactivate()
            Node.activeNode = null
            
    activate: ->
        
        @gizmo.center.scale.set 1.2 1.2 1.2
        @gizmo.center.material = Materials.ctrl.start
        @gizmo.tangent.visible = true
        
    deactivate: ->
        
        @gizmo.center.scale.set 1 1 1
        @gizmo.center.material = Materials.ctrl.curve  
        @gizmo.tangent.visible = false
            
    # 0000000    00000000    0000000    0000000   
    # 000   000  000   000  000   000  000        
    # 000   000  0000000    000000000  000  0000  
    # 000   000  000   000  000   000  000   000  
    # 0000000    000   000  000   000   0000000   
    
    startDrag: (tracks) ->
        
        dir = vec @dir
        if tracks == @inTracks
            dir.negate()
        
        n1 = @
        n2 = world.addNode @position.plus dir
        
        n2.setDir dir
        
        c1 = dir.clone().scale( 5).add n1.position
        c2 = dir.clone().scale(-5).add n2.position
        t = world.addTrack [n1.position.clone(), c1, c2, n2.position.clone()]
                
        t.node[0] = n1
        t.node[1] = n2
        
        tracks.push t
        n2.inTracks.push t
                        
        @dragTrack = t
        
    onInDrag: (ray, hit) =>
        
        if not @dragTrack
            @startDrag @inTracks
            
        @moveInOutDrag ray, hit
                    
    onOutDrag: (ray, hit) =>
        
        if not @dragTrack
            @startDrag @outTracks

        @moveInOutDrag ray, hit
            
    moveInOutDrag: (ray, hit) ->
        
        dragNode = @dragTrack.node[1]
            
        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, hit.mesh.getWorldPosition(Vector.tmp)
        ray.intersectPlane plane, dragNode.position
        dragNode.position.round()
        dragNode.group.position.copy dragNode.position
        @dragTrack.nodeMoved dragNode
        
    onDragDone: =>
        
        delete @dragTrack
            
    onDrag: (ray, hit) =>

        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, hit.mesh.getWorldPosition(Vector.tmp)
        ray.intersectPlane plane, @position
        
        @position.round()
        @group.position.copy @position
        
        for track in @outTracks
            track.nodeMoved @
        for track in @inTracks
            track.nodeMoved @
        
        for i in 0...@blockedTrains.length
            
            block = @blocks[i]
            train = @blockedTrains[i]
            train.path.getPoint block.position, 3
        
        if @nodeBox
            @nodeBox.position.copy @position
                
    # 00000000    0000000   000000000   0000000   000000000  00000000  
    # 000   000  000   000     000     000   000     000     000       
    # 0000000    000   000     000     000000000     000     0000000   
    # 000   000  000   000     000     000   000     000     000       
    # 000   000   0000000      000     000   000     000     00000000  
    
    onRotate: (ray, hit, downRay, lastRay) =>

        point = vec()
        hit.mesh.getWorldPosition point
        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, point
        lastRay.intersectPlane plane, Vector.tmp
        ray.intersectPlane plane, Vector.tmp2
        
        Vector.tmp.sub point
        Vector.tmp2.sub point
        angle = @dir.angle(Vector.tmp2)-@dir.angle(Vector.tmp)
        if angle
            @rotate Math.sign(@dir.crossed(@up).dot Vector.tmp) * -angle
            for track in @outTracks
                track.nodeRotated @
            for track in @inTracks
                track.nodeRotated @
            
    rotate: (degree) ->

        quat = Quaternion.axisAngle @up, degree
        @dir.applyQuaternion quat
        @group.quaternion.multiply quat
        @nodeBox?.quaternion.copy @group.quaternion
        
    setDir: (dir) ->
        
        quat = Quaternion.unitVectors @dir, dir
        @dir.copy dir
        @group.quaternion.multiply quat
        @nodeBox?.quaternion.copy @group.quaternion
        
    # 000000000  00000000    0000000   000  000   000  
    #    000     000   000  000   000  000  0000  000  
    #    000     0000000    000000000  000  000 0 000  
    #    000     000   000  000   000  000  000  0000  
    #    000     000   000  000   000  000  000   000  
    
    setTrain: (@train) ->
        
        if @train 
            if not @nodeBox
                c1 = new CylinderGeometry 0.25 0.25 1 16
                c1.rotateX Math.PI/2
                c2 = new CylinderGeometry 0.25 0.25 1.4 16
                c2.rotateZ Math.PI/2
                geom = THREE.BufferGeometryUtils.mergeBufferGeometries [c1, c2]
                @nodeBox = new Mesh geom, @train.cars[0].mesh.material
                @nodeBox.position.copy @position
                @nodeBox.quaternion.copy @group.quaternion
                world.addObject @nodeBox
            @nodeBox.material = @train.cars[0].mesh.material
            for block in @blocks
                block.material = @nodeBox.material
        
    # 0000000    000       0000000    0000000  000   000  
    # 000   000  000      000   000  000       000  000   
    # 0000000    000      000   000  000       0000000    
    # 000   000  000      000   000  000       000  000   
    # 0000000    0000000   0000000    0000000  000   000  
    
    block: (train) ->
        
        @blockedTrains.push train
        train.block()
        
        geom = THREE.BufferGeometryUtils.mergeBufferGeometries [new BoxGeometry(0.5 1 0.5), new BoxGeometry(1 0.5 0.5)]
        
        mesh = new Mesh geom, @train.cars[0].mesh.material
        train.path.getPoint mesh.position, 3
        train.path.getTangent Vector.tmp, 3
        Vector.tmp.add mesh.position
        mesh.lookAt Vector.tmp
        world.addObject mesh
        @blocks.push mesh
        
    unblock: ->
        
        @setTrain null
        
        for t in @blockedTrains
            t.unblock()            
        
        for block in @blocks
            world.removeObject block
        world.removeObject @nodeBox
            
        delete @nodeBox
        @blockedTrains = []
        @blocks = []
        
    # 000000000  00000000    0000000    0000000  000   000  
    #    000     000   000  000   000  000       000  000   
    #    000     0000000    000000000  000       0000000    
    #    000     000   000  000   000  000       000  000   
    #    000     000   000  000   000   0000000  000   000  
    
    removeTrack: (track) ->
        
        tracks = @siblingTracks track
        tracks.splice tracks.indexOf(track), 1
        track.del()
        
    siblingTracks: (track) ->
        
        if 
            track in @inTracks  ➜ @inTracks
            track in @outTracks ➜ @outTracks
                                ➜ log 'no siblingTrack' 
        
module.exports = Node
