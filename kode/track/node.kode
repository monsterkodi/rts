###
000   000   0000000   0000000    00000000
0000  000  000   000  000   000  000     
000 0 000  000   000  000   000  0000000 
000  0000  000   000  000   000  000     
000   000   0000000   0000000    00000000
###

CurveCtrl = require './curvectrl'
Compass   = require './compass'

function Node

    @numNodes: 0
    Node.clickMode: false

    @: (point, @name) ->
        
        Node.numNodes++
        
        @name = "n#{Node.numNodes}" if not @name
        
        @inTracks  = []
        @outTracks = []
        @blockedTrains = []
        @blocks = []
        @gizmo = {}

        @group = new Group
        @group.name = @name
        @group.position.copy point
        
        geom = Geom.cylinder 0.71 0.7 32
        @center = new Mesh geom, Materials.node.center
        @center.name = 'node.center'
        @center.onClick = @onClickCenter
        @center.onDoubleClick = @onDoubleClickCenter
        @center.onEnter = @onEnterCenter
        @center.onLeave = @onLeaveCenter
        @center.onDrag  = @onDrag
        
        geom = new CylinderGeometry 0.5 0.5 1 32
        geom.translate 0 0 -2
        geom.rotateX Math.PI/2
        
        @outMesh = new Mesh geom, Materials.node.out
        @outMesh.name       = @name + '.out'
        @outMesh.onDrag     = @onOutDrag
        @outMesh.onDragDone = @onDragDone
        @outMesh.onEnter    = @onEnterOut
        @outMesh.onLeave    = @onLeaveOut
        @outMesh.onClick    = @onClickInOut

        geom = new CylinderGeometry 0.5 0.5 1 32
        geom.translate 0 0 2
        geom.rotateX Math.PI/2
        
        @inMesh = new Mesh geom, Materials.node.in
        @inMesh.name       = @name + '.in'
        @inMesh.onDrag     = @onInDrag
        @inMesh.onDragDone = @onDragDone
        @inMesh.onEnter    = @onEnterIn
        @inMesh.onLeave    = @onLeaveIn
        @inMesh.onClick    = @onClickInOut
        
        @group.add @center
        @group.add @inMesh
        @group.add @outMesh
        
        world.addPickable @group
        world.addObject   @group
        
        @rotate 0
        
    del: ->
        
        world.hideCompass @
        world.removeObject @group
        world.removePickable @group
        delete @group
        
    onDoubleClickCenter: =>
        
        if @inTracks.length == 1 and @outTracks.length == 1
            post.emit 'convertNodeToCtrl' @
        
    onClickCenter: => 
        if not Node.clickMode
            if world.compass.object == @
                log 'hideCompass' Node.clickMode
                world.hideCompass @
            else
                log 'showCompass' Node.clickMode
                world.showCompass @, @getPos(), @getDir()
            
    onEnterIn:     => @inMesh.material  = Materials.node.highlightIn
    onLeaveIn:     => @inMesh.material  = Materials.node.in
    onEnterCenter: => @center.material  = Materials.ctrl.highlight
    onLeaveCenter: => @center.material  = Materials.node.center
    onEnterOut:    => @outMesh.material = Materials.node.highlightOut
    onLeaveOut:    => @outMesh.material = Materials.node.out
    
    onClickInOut: (ray, hit) => 

        return if Node.clickMode
        
        @clickTracks = hit.name?.endsWith('.in') ? @inTracks : @outTracks
        Node.clickMode = true
        log 'onClickInOut start' Node.clickMode, @dragTrack
        if not @dragTrack
            @startDrag @clickTracks
        
        post.on 'mouseMove'  @onMouseMove
        post.on 'mouseDown'  @onMouseDown
        post.on 'mouseUp'    @onMouseUp
        
    onMouseMove: (ray, hit) =>
        
        if Node.clickMode
            @moveInOutDrag ray, hit
        
    onMouseDown: (ray, hit) =>
    onMouseUp: (ray, hit) =>
        
        delete @clickTracks
        log 'onMouseUp' Node.clickMode
        post.removeListener 'mouseMove'  @onMouseMove
        post.removeListener 'mouseDown'  @onMouseDown
        post.removeListener 'mouseUp'    @onMouseUp
        Node.clickMode = false
        
    # 0000000    00000000    0000000    0000000   
    # 000   000  000   000  000   000  000        
    # 000   000  0000000    000000000  000  0000  
    # 000   000  000   000  000   000  000   000  
    # 0000000    000   000  000   000   0000000   
    
    startDrag: (tracks) ->
        
        world.hideCompass @
        
        dir = @getDir()
        if tracks == @inTracks
            dir.negate()
        
        n1 = @
        n2 = world.addNode @getPos().add dir
        
        n2.setDir dir
        
        c1 = dir.clone().scale( 5).add n1.getPos()
        c2 = dir.clone().scale(-5).add n2.getPos()
        t = world.addTrack n1, n2, [c1, c2]
                
        t.node[0] = n1
        t.node[1] = n2
        
        tracks.push t
        n2.inTracks.push t
        
        log 'start drag'
        
        @dragTrack = t
        
    onInDrag: (ray, hit) =>
        
        if not @dragTrack
            @startDrag @inTracks
            
        @moveInOutDrag ray, hit
                    
    onOutDrag: (ray, hit) =>
        
        if not @dragTrack
            @startDrag @outTracks

        @moveInOutDrag ray, hit
            
    moveInOutDrag: (ray, hit) ->
        
        dragNode = @dragTrack.node[1]
            
        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, @getPos()
        ray.intersectPlane plane, Vector.tmp
        Vector.tmp.round()
        dragNode.group.position.copy Vector.tmp # setPos?
        @dragTrack.nodeMoved dragNode
        
    onDragDone: =>
        if not Node.clickMode
            delete @dragTrack
            
    onDrag: (ray, hit) =>

        world.hideCompass @
        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, hit.mesh.getWorldPosition(Vector.tmp)
        ray.intersectPlane plane, Vector.tmp
        Vector.tmp.round()
        @setPos Vector.tmp
        
    getPos: => @group.position.clone()
    setPos: (point) ->
        
        @group.position.copy point
        
        for track in @outTracks
            track.nodeMoved @
        for track in @inTracks
            track.nodeMoved @
        
        for i in 0...@blockedTrains.length
            
            block = @blocks[i]
            train = @blockedTrains[i]
            train.path.getPoint block.position, 3
        
    # 00000000    0000000   000000000   0000000   000000000  00000000  
    # 000   000  000   000     000     000   000     000     000       
    # 0000000    000   000     000     000000000     000     0000000   
    # 000   000  000   000     000     000   000     000     000       
    # 000   000   0000000      000     000   000     000     00000000  
    
    onRotate: (ray, hit, downRay, lastRay) =>

        point = vec()
        hit.mesh.getWorldPosition point
        plane = new Plane
        plane.setFromNormalAndCoplanarPoint Vector.unitZ, point
        lastRay.intersectPlane plane, Vector.tmp
        ray.intersectPlane plane, Vector.tmp2
        
        Vector.tmp.sub point
        Vector.tmp2.sub point
        angle = @getDir().angle(Vector.tmp2)-@getDir().angle(Vector.tmp)
        if angle
            @rotate Math.sign(@getDir().crossed(@getUp()).dot Vector.tmp) * -angle
            
    rotate: (degree) ->

        @setDir @getDir().applyQuaternion Quaternion.axisAngle @getUp(), degree
        
    compassRotated: (dir) => @setDir dir
        
    getUp: -> vec(Vector.unitZ).applyQuaternion @group.quaternion
    getDir: -> vec(Vector.unitY).applyQuaternion @group.quaternion
    setDir: (dir) ->
        
        quat = Quaternion.unitVectors Vector.unitY, dir
        @group.quaternion.copy quat
        
        for track in @outTracks
            track.nodeRotated @
        for track in @inTracks
            track.nodeRotated @
        
    # 000000000  00000000    0000000   000  000   000  
    #    000     000   000  000   000  000  0000  000  
    #    000     0000000    000000000  000  000 0 000  
    #    000     000   000  000   000  000  000  0000  
    #    000     000   000  000   000  000  000   000  
    
    setTrain: (@train) ->
        
        if @train 
            if not @nodeBox
                c1 = new CylinderGeometry 0.25 0.25 1 16
                c1.rotateX Math.PI/2
                c2 = new CylinderGeometry 0.25 0.25 1.6 16
                c2.rotateZ Math.PI/2
                geom = Geom.merge c1, c2
                @nodeBox = new Mesh geom, @train.cars[0].mesh.material
                @group.add @nodeBox
            @nodeBox.material = @train.cars[0].mesh.material
            for block in @blocks
                block.material = @nodeBox.material
        
    # 0000000    000       0000000    0000000  000   000  
    # 000   000  000      000   000  000       000  000   
    # 0000000    000      000   000  000       0000000    
    # 000   000  000      000   000  000       000  000   
    # 0000000    0000000   0000000    0000000  000   000  
    
    block: (train) ->
        
        @blockedTrains.push train
        train.block()
        
        geom = Geom.merge new BoxGeometry(0.5 1 0.5), new BoxGeometry(1 0.5 0.5)
        
        mesh = new Mesh geom, @train.cars[0].mesh.material
        train.path.getPoint mesh.position, 3
        train.path.getTangent Vector.tmp, 3
        Vector.tmp.add mesh.position
        mesh.lookAt Vector.tmp
        world.addObject mesh
        @blocks.push mesh
        
    unblock: ->
        
        @setTrain null
        
        for t in @blockedTrains
            t.unblock()            
        
        for block in @blocks
            world.removeObject block
        
        @nodeBox.removeFromParent()
        delete @nodeBox
        @blockedTrains = []
        @blocks = []
        
    # 000000000  00000000    0000000    0000000  000   000  
    #    000     000   000  000   000  000       000  000   
    #    000     0000000    000000000  000       0000000    
    #    000     000   000  000   000  000       000  000   
    #    000     000   000  000   000   0000000  000   000  
    
    removeTrack: (track) ->
        
        tracks = @siblingTracks track
        tracks.splice tracks.indexOf(track), 1
        track.del()
        
    siblingTracks: (track) ->
        
        if 
            track in @inTracks  ➜ @inTracks
            track in @outTracks ➜ @outTracks
                                ➜ log 'no siblingTrack' 
        
module.exports = Node
