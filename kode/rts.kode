###
00000000   000000000   0000000
000   000     000     000     
0000000       000     0000000 
000   000     000          000
000   000     000     0000000 
###

kxk = require 'kxk'

{ _, clamp, deg2rad, elem, first, klog, kstr, last, post, prefs, rad2deg, randInt, randIntRange, stopEvent } = require 'kxk'

{ Bot, Stone, Geom, Face, Edge, Bend } = require './constants'

window.$            = kxk.$
window._            = _
window.post         = post
window.prefs        = prefs
window.randInt      = randInt
window.randIntRange = randIntRange
window.deg2rad      = deg2rad
window.rad2deg      = rad2deg
window.stopEvent    = stopEvent
window.clamp        = clamp
window.first        = first
window.last         = last
window.elem         = elem
window.str          = kstr
window.log          = klog

window.Bot          = Bot
window.Edge         = Edge
window.Bend         = Bend
window.Geom         = Geom
window.Face         = Face
window.Stone        = Stone
window.THREE        = require 'three'
window.Vector       = require './lib/vector'
window.Quaternion   = require './lib/quaternion'
window.Color        = require './color'
window.Geometry     = require './geometry'
window.Materials    = require './materials'
window.playSound    = (o,n,c) -> rts.sound.play o,n,c
   
FPS     = require './lib/fps'
Info    = require './lib/info'
Debug   = require './lib/debug'
Sound   = require './lib/sound'
Config  = require './config'
Menu    = require './menu/menu'
World   = require './world'
Map     = require './map'
Camera  = require './camera'
Handle  = require './handle'

class RTS

    @: (@view) ->
        
        window.rts = @
        window.config = Config.default
                
        @sound = new Sound
        
        @fps = new FPS
        @paused = false
        @animations = []
        @worldAnimations = []
        
        @renderer = new THREE.WebGLRenderer antialias: true
        @renderer.setPixelRatio window.devicePixelRatio

        @renderer.setClearColor Color.menu.background     
        @renderer.setSize @view.clientWidth, @view.clientHeight
        @renderer.shadowMap.enabled = true
        @renderer.shadowMap.type = THREE.PCFSoftShadowMap
        
        # log @renderer.capabilities
        
        @view.appendChild @renderer.domElement
        
        @camera = new Camera view:@view
                
        @scene = new THREE.Scene()
                
        @lightPlayer = new THREE.PointLight 0xffffff, 0.5
        @lightPlayer.position.copy @player.camera.getPosition() if @player?
        @lightPlayer.position.copy @camera.position
        @scene.add @lightPlayer

        @lightShadow = new THREE.DirectionalLight
        @lightShadow.intensity = 1.0
        @lightShadow.castShadow = true
        @lightShadow.position.set 100 0 100
        @lightShadow.target.position.set 0 0 0
        @lightShadow.shadow.mapSize.width  = 2*2048
        @lightShadow.shadow.mapSize.height = 2*2048
        @lightShadow.shadow.camera.near    = 0.5
        @lightShadow.shadow.camera.far     = 500
        @lightShadow.shadow.camera.left    = -50
        @lightShadow.shadow.camera.right   =  50
        @lightShadow.shadow.camera.top     =  50
        @lightShadow.shadow.camera.bottom  = -50
        @scene.add @lightShadow
        @scene.add @lightShadow.target
        @lightShadowHelper = new THREE.DirectionalLightHelper @lightShadow, 5, new THREE.Color 0xffff00
        @lightShadowHelper.visible = false
        @scene.add @lightShadowHelper
        
        @lightAmbient = new THREE.AmbientLight 0x333333
        @scene.add @lightAmbient
        
        @gridHelper = new THREE.GridHelper 100, 100, 0x444444, 0x111111
        @gridHelper.rotateX deg2rad 90
        @gridHelper.position.set 0 0 0.1
        @gridHelper.visible = false
        @scene.add @gridHelper
        
        @axesHelper = new THREE.AxesHelper 50
        @axesHelper.position.set 0 0 0.1
        @axesHelper.visible = false
        @scene.add @axesHelper
        
        @shadowCameraHelper = new THREE.CameraHelper @lightShadow.shadow.camera
        @shadowCameraHelper.visible = false
        @scene.add @shadowCameraHelper
        
        @arrowHelper = new THREE.ArrowHelper vec(0 0 1), vec(), 1, 0x4444ff
        @scene.add @arrowHelper
        
        new Map @scene # sets window.world
        window.handle = new Handle
                
        @mouse   = vec()
        @downPos = vec()
        
        @raycaster = new THREE.Raycaster()
        
        document.addEventListener 'mousemove' @onMouseMove
        document.addEventListener 'mousedown' @onMouseDown
        document.addEventListener 'mouseup'   @onMouseUp
        document.addEventListener 'dblclick'  @onDblClick
        
        @menu = new Menu
        
        @lastAnimationTime = window.performance.now()
                
        @animationStep()

    #  0000000   000   000  000  00     00   0000000   000000000  00000000  
    # 000   000  0000  000  000  000   000  000   000     000     000       
    # 000000000  000 0 000  000  000000000  000000000     000     0000000   
    # 000   000  000  0000  000  000 0 000  000   000     000     000       
    # 000   000  000   000  000  000   000  000   000     000     00000000  
    
    animate: (func) ->
        
        @animations.push func
        
    animateWorld: (func) ->
        
        @worldAnimations.push func
        
    togglePause: -> 
    
        @paused = not @paused
        post.emit 'pause' @paused
    
    animationStep: =>
        
        now = window.performance.now()
        delta = (now - @lastAnimationTime) * 0.001
        @lastAnimationTime = now
        
        oldAnimations = @animations.clone()
        @animations = []
        for animation in oldAnimations
            animation delta
        
        @menu.animate delta
         
        if not @paused
            
            angle = -delta*0.5*world.speed
            @lightShadow.position.applyQuaternion Quaternion.axisAngle Vector.unitZ, angle
            @lightShadowHelper.update()   
            
            world.animate delta
             
            oldWorldAnimations = @worldAnimations.clone()
            @worldAnimations = []
            for animation in oldWorldAnimations
                animation delta * world.speed
                    
        @render()

        setTimeout @animationStep, 1000/60
            
    # 00     00   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000       000       
    # 000000000  000   000  000   000  0000000   0000000   
    # 000 0 000  000   000  000   000       000  000       
    # 000   000   0000000    0000000   0000000   00000000  
    
    onMouseDown: (event) =>
        
        @calcMouse event
        @downPos.copy @mouse
        @camMove = event.button != 1
            
    onMouseUp: (event) =>

        delete @camMove
        
        @calcMouse event

        moved = @downPos.dist @mouse
        if moved < 0.01
            if event.button != 0
                @focusOnHit()
                    
    onMouseMove: (event) =>

        @calcMouse event
        hit = @castRay()
        
    onDblClick: (event) => 

        if not event.target.button
            handle.doubleClick()
                            
    calcMouse: (event) ->
        
        br = @view.getBoundingClientRect()
        
        @mouse.x = ((event.clientX-br.left) / br.width) * 2 - 1
        @mouse.y = -((event.clientY-br.top) / br.height ) * 2 + 1
        @mouse
        
    focusOnHit: ->

        if hit = @castRay()
            if hit.bot
                @camera.fadeToPos hit.bot.pos
            else    
                @camera.fadeToPos hit.pos

    #  0000000   0000000    0000000  000000000  00000000    0000000   000   000  
    # 000       000   000  000          000     000   000  000   000   000 000   
    # 000       000000000  0000000      000     0000000    000000000    00000    
    # 000       000   000       000     000     000   000  000   000     000     
    #  0000000  000   000  0000000      000     000   000  000   000     000     
    
    castRay: ->

        @raycaster.setFromCamera @mouse, @camera
        intersects = @raycaster.intersectObjects world.pickables, true

        intersect = intersects[0]
        
        return if not intersect
        
        point = vec intersect.point
        pos   = world.roundPos point
        
        Vector.tmp.set 0 0 1
        if not intersect.face
            log intersect
        norm = intersect.face ? intersect.face.normal : Vector.tmp
        
        @arrowHelper.setDirection norm
        @arrowHelper.position.copy point
        
        info = 
            pos:    pos
            index:  world.indexAtPos pos
            norm:   norm
            point:  point
            dist:   intersect.distance
        
        @scene.remove @cursor if @cursor
        delete @cursor
            
        if intersect.object.bot
            info.bot = world.botAtPos point
        
        stones = intersects.filter (i) => i.object.stone?
        if stones.length
            info.face = world.faceAtPosNorm stones[0].point, stones[0].face.normal
        
        info
        
    # 00000000   00000000  000   000  0000000    00000000  00000000   
    # 000   000  000       0000  000  000   000  000       000   000  
    # 0000000    0000000   000 0 000  000   000  0000000   0000000    
    # 000   000  000       000  0000  000   000  000       000   000  
    # 000   000  00000000  000   000  0000000    00000000  000   000  
    
    render: ->

        @lightPlayer.position.copy @camera.position
        @renderer.render world.scene, @camera
        
        @fps.draw()
        
        return if @paused

        if prefs.get 'info'
            @info = new Info if not @info
            @info.draw()
        else if @info?
            @info.del()
            delete @info
            
        if prefs.get 'debug'
            @debug = new Debug if not @debug
        else if @debug
            @debug.del()
            delete @debug

    # 00000000   00000000   0000000  000  0000000  00000000  0000000  
    # 000   000  000       000       000     000   000       000   000
    # 0000000    0000000   0000000   000    000    0000000   000   000
    # 000   000  000            000  000   000     000       000   000
    # 000   000  00000000  0000000   000  0000000  00000000  0000000  
    
    resized: (w,h) ->
        
        @camera.aspect = w/h
        @camera.size = vec w,h
        @camera.updateProjectionMatrix()
        @renderer.setSize w,h
        
module.exports = RTS
