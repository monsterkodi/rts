###
 0000000   0000000   000   000  00000000
000       000   000  000   000  000     
0000000   000000000   000 000   0000000 
     000  000   000     000     000     
0000000   000   000      0      00000000
###

Immutable = require 'seamless-immutable'

function Save

    @: ->
        
        @s = Immutable
            nodes:    {}
            tracks:   {}
            stations: {}
            
        post.on 'save'   @onSave
        post.on 'reload' @onLoad
        
    onSave: =>
        
        @update()
        
    nodes:  -> @s.nodes.asMutable  deep:true
    tracks: -> @s.tracks.asMutable deep:true
    
    # 000   000  00000000   0000000     0000000   000000000  00000000  
    # 000   000  000   000  000   000  000   000     000     000       
    # 000   000  00000000   000   000  000000000     000     0000000   
    # 000   000  000        000   000  000   000     000     000       
    #  0000000   000        0000000    000   000     000     00000000  
    
    update: ->

        state = 
            nodes:    {}
            tracks:   {}
            stations: {}

        childs = world.scene.children.filter (child) -> child.toSave is func
        for child in childs
            state[child.toSave.key][child.name] = child.toSave()
        
        @s = @s.set 'stations' state.stations
        @s = @s.set 'nodes'    state.nodes
        @s = @s.set 'tracks'   state.tracks
        
        save = noon.stringify @s, circular:true
        # log save
        prefs.set 'save' save
        @
        
    # 000       0000000    0000000   0000000    
    # 000      000   000  000   000  000   000  
    # 000      000   000  000000000  000   000  
    # 000      000   000  000   000  000   000  
    # 0000000   0000000   000   000  0000000    
    
    onLoad: =>
        
        save = noon.parse prefs.get 'save'
        log 'load:' prefs.get 'save'
        
        world.clear()
        
        for name,node of save.nodes

            world.addNode node
            
        for name,station of save.stations

            s = world.addStation station
            s.node = world.nodeWithName station.node
            
        for name,track of save.tracks

            n1 = world.nodeWithName track.node[0]
            n2 = world.nodeWithName track.node[1]
            
            ctrl = track.ctrl.map (c) -> vec c
            t = world.addTrack n1, n2, ctrl, name
            
            s1 = save.nodes[n1.name]
            if name in s1.in ? []
                n1.inTracks.push t
            else
                n1.outTracks.push t
                
            s2 = save.nodes[n2.name]
            if name in s2.in ? []
                n2.inTracks.push t
            else
                n2.outTracks.push t
            
module.exports = Save
