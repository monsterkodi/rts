###
000000000  00000000    0000000   00000000  00000000  000   0000000
   000     000   000  000   000  000       000       000  000     
   000     0000000    000000000  000000    000000    000  000     
   000     000   000  000   000  000       000       000  000     
   000     000   000  000   000  000       000       000   0000000
###

HEAD_DISTANCE    = 12
TAIL_DISTANCE    = 8
REAREND_DISTANCE = 8

function Traffic

    @:     -> @clear()
    clear: -> @trains = []
        
    addTrain: (train) -> @trains.push train
    subTrain: (train) -> 
        
        path = train.path
        
        if nn = path.nextNode()
            nn.unblockTrain train
            if nn.train == train
                nn.unblockAll()

        if pn = path.prevNode()
            if pn.train == train
                pn.unblockAll()
                
        # go trough all nodes from head to tail here?
                
        if tpn = path.prevNode train.tailDelta()
            if tpn.train == train
                tpn.unblockAll()
        
        if (i = @trains.indexOf train) >= 0
            @trains.splice i, 1
        
    simulate: (scaledDelta, timeSum) ->
        
        â–´ scaledDelta > 0
        
        @nodeSignals()
        
        for train in @trains
            
            advance = scaledDelta * train.speed
            if advance > 0
                advance = @allowTrainAdvance train, advance
            if advance
                train.advance advance
                
            train.update scaledDelta, timeSum
        
    nodeSignals: ->
        
        for train in @trains
            if path = train.path
                nd = path.nextDistance()
                if nd < HEAD_DISTANCE                         # train is close to target node
                    nn = path.nextNode()
                    if nn and nn.train != train               # if node is not owned by train
                        if not nn.train                       #      if node not occupied
                            nn.setTrain train                 #          train occupies node 
                        else 
                            if train not in nn.blockedTrains  # if train not alreay blocked by node
                                if path.currentTrack()  != nn.train.tailTrack() and 
                                    path.currentTrack() != nn.train.prevTailTrack() and
                                    path.nextTrack()    != nn.train.tailTrack()
                                    nn.blockTrain train       #      train gets blocked
                                else 
                                    if path.currentTrack() == nn.train.prevTailTrack()
                                        nn.setTrain train     # train is the new occupant
                
                if ct = path.currentTrack()
                    if not ct.hasTrain train
                        train.track.subTrain train
                        train.track = ct
                        train.track.addTrain train
                                        
                tailDelta = train.tailDelta()
                tpd = path.prevDistance tailDelta
                tnd = path.nextDistance tailDelta
                if tpd > min TAIL_DISTANCE, tnd+tpd/2
                    tpn = path.prevNode tailDelta
                    if tpn.train == train
                        tpn.unblockAll()
                                    
    #  0000000   0000000    000   000   0000000   000   000   0000000  00000000  
    # 000   000  000   000  000   000  000   000  0000  000  000       000       
    # 000000000  000   000   000 000   000000000  000 0 000  000       0000000   
    # 000   000  000   000     000     000   000  000  0000  000       000       
    # 000   000  0000000        0      000   000  000   000   0000000  00000000  
    
    allowTrainAdvance: (train, advance) ->
        
        path = train.path
        oldAdvance = advance
        
        halfEngineLength = 1.9
        maxAdvance = path.getLength()-path.delta-halfEngineLength
        if advance > maxAdvance < 0.0001
            if @extendTrainPath train
                return @allowTrainAdvance train, advance
            else
                if train.isOneWay()
                    return maxAdvance
                else
                    train.reverse()
                    return @allowTrainAdvance train, advance

        advance = Math.min maxAdvance, advance
            
        advance = @checkCargo train, advance
            
        delta = path.normDelta path.delta+advance
        
        track = path.trackAtDelta delta
        
        for other in @trains
            continue if other == train
            if other.tailTrack() == track
                trainToOther = other.tailPrevDistance() - path.prevDistance(delta)
                if trainToOther >= 0 and trainToOther < REAREND_DISTANCE
                    advance = 0
                    break
            else if other.prevTailTrack() == track
                trainToOther = other.tailPrevDistance() + path.nextDistance(delta)
                if trainToOther < REAREND_DISTANCE
                    advance = 0
                    break
            if other.headTrack() == track
                if path.revers[path.indexAtDelta delta] != other.trackRevers()
                    dist = Math.abs track.trainCurveDistance(train) - track.trainCurveDistance(other)
                    if dist < 4.5
                        log 'heads on collision!'
                        world.physics.addTrain train
                        world.physics.addTrain other
                        advance = 0
                        break
                    
        train.advanceFactor = advance/oldAdvance
        advance
        
    extendTrainPath: (train) ->
        
        nn = train.path.nextNode()
        ot = nn.oppositeTracks train.path.currentTrack()
        mode = ot == nn.outTracks ? 1 : 2
        for nextTrack in ot
            nextNode  = nextTrack.nodeOpposite nn
            trackMode = nextTrack.modeForNode(nn) or 3
            if not (mode & trackMode)
                continue # track points in the wrong direction
            nnopptrck = nextNode.oppositeTracks(nextTrack) ? []
            if nnopptrck.length
                train.path.addTrackNode nextTrack, nextNode
                return nextTrack
            
    checkCargo: (train, advance) ->
        
        # log 'checkCargo' train.name, advance
        maxAdvance = advance
        minCar = null
        for car in train.boxcars()
            if car.isEmpty()
                if car.waitingForCargo
                    # log 'waitingForCargo' train.name
                    return 0
                if resource = car.nextNode().station?.providesCargo()
                    if car.train.resource[resource]
                        if car.nextDistance() < maxAdvance
                            minCar = car
                            maxAdvance = car.nextDistance()
            else
                if car.waitingForUnload
                    # log 'waitingForUnload' train.name
                    return 0
                if car.nextNode().station?.takesCargo()
                    if car.nextDistance() < maxAdvance
                        minCar = car
                        maxAdvance = car.nextDistance()
                        
        if minCar
            if minCar.isEmpty()
                # log 'startWaitingForCargo' minCar.name
                minCar.waitingForCargo = true
                if not car.nextNode().station?.carWaitingForCargo is func 
                    log car.nextNode()
                else
                    car.nextNode().station.carWaitingForCargo minCar
            else
                minCar.waitingForUnload = true
                # log 'startWaitingForUnload' minCar.name
                car.nextNode().station.carWaitingForUnload minCar
        maxAdvance

module.exports = Traffic
