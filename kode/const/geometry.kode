###
 0000000   00000000   0000000   00     00  00000000  000000000  00000000   000   000
000        000       000   000  000   000  000          000     000   000   000 000 
000  0000  0000000   000   000  000000000  0000000      000     0000000      00000  
000   000  000       000   000  000 0 000  000          000     000   000     000   
 0000000   00000000   0000000   000   000  00000000     000     000   000     000   
###
log 'geometry' window
CSG       = require "../lib/csg"
geomMerge = require "../lib/merge"

subtract  = (a,b) -> CSG.toGeometry CSG.fromGeometry(a).subtract  CSG.fromGeometry b
intersect = (a,b) -> CSG.toGeometry CSG.fromGeometry(a).intersect CSG.fromGeometry b
union     = (a,b) -> CSG.toGeometry CSG.fromGeometry(a).union     CSG.fromGeometry b
merge     = -> 
    if arguments.length == 1 and arguments[0] is Array
        geomMerge arguments[0]
    else
        geomMerge.apply null, [arguments]

class Geometry
    
    @merge:     merge
    @union:     union
    @subtract:  subtract
    @intersect: intersect
    
    @test: ->
        
        @subtract @box(), @box(0.5, 0.5)
                
    # 0000000     0000000   000   000  
    # 000   000  000   000   000 000   
    # 0000000    000   000    00000    
    # 000   000  000   000   000 000   
    # 0000000     0000000   000   000  
    
    @box: (w=1, h=1, d=1, x=0, y=0, z=0) ->
        
        geom = new BoxGeometry w, h, d
        geom.translate x, y, z
        geom
        
    #  0000000  00000000   000   000  00000000  00000000   00000000  
    # 000       000   000  000   000  000       000   000  000       
    # 0000000   00000000   000000000  0000000   0000000    0000000   
    #      000  000        000   000  000       000   000  000       
    # 0000000   000        000   000  00000000  000   000  00000000  
    
    @sphere: (size=1, sgmt=16, x=0, y=0, z=0) ->
        
        geom = new SphereGeometry size, sgmt, sgmt
        geom.translate x, y, z
        geom
        
    #  0000000  000   000  000      000  000   000  0000000    00000000  00000000   
    # 000        000 000   000      000  0000  000  000   000  000       000   000  
    # 000         00000    000      000  000 0 000  000   000  0000000   0000000    
    # 000          000     000      000  000  0000  000   000  000       000   000  
    #  0000000     000     0000000  000  000   000  0000000    00000000  000   000  
    
    @cylinder: (height=1, radius=0.5, sgmt=24, x=0, y=0, z=0) ->
        
        geom = new CylinderGeometry radius, radius, height, sgmt
        geom.rotateX Math.PI/2
        geom.translate x, y, z
        geom
        
    #  0000000  000   000  000      000  000   000  0000000     0000000   000   000  000   000  000000000  
    # 000        000 000   000      000  0000  000  000   000  000   000  0000  000  000   000     000     
    # 000         00000    000      000  000 0 000  000   000  000   000  000 0 000  000   000     000     
    # 000          000     000      000  000  0000  000   000  000   000  000  0000  000   000     000     
    #  0000000     000     0000000  000  000   000  0000000     0000000   000   000   0000000      000     
    
    @cylindonut: (height=1, outerRadius=1, innerRadius=outerRadius/2, sgmt=24) ->
        
        geom  = @cylinder height, outerRadius, sgmt
        inner = @cylinder height, innerRadius, sgmt
        geom  = @subtract geom, inner
        geom
        
    # 00000000   000  000      000      
    # 000   000  000  000      000      
    # 00000000   000  000      000      
    # 000        000  000      000      
    # 000        000  0000000  0000000  
    
    @pill: (length, radius, segmts) ->

        l = length ? 1
        r = radius ? 0.5
        s = segmts ? 8
        
        top = new SphereGeometry r, s, s/2, 0, 2*Math.PI, 0, Math.PI/2
        top.translate 0 l/2 0
        mid = new CylinderGeometry r, r, l, s, 1 true
        bot = new SphereGeometry r, s, s/2, 0, 2*Math.PI, Math.PI/2, Math.PI/2
        bot.translate 0 -l/2 0
        
        pill = @merge top, mid, bot
        
        pill.rotateX Math.PI/2
        pill
        
    #  0000000   0000000   00000000   000   000  00000000  00000000   0000000     0000000   000   000  
    # 000       000   000  000   000  0000  000  000       000   000  000   000  000   000   000 000   
    # 000       000   000  0000000    000 0 000  0000000   0000000    0000000    000   000    00000    
    # 000       000   000  000   000  000  0000  000       000   000  000   000  000   000   000 000   
    #  0000000   0000000   000   000  000   000  00000000  000   000  0000000     0000000   000   000  
    
    @quad: (cfg) ->
        
        sz = cfg.size ? vec(cfg.size) : vec 1 1

        normal = cfg.normal ? Vector.unitZ

        geom = new PlaneGeometry sz.x, sz.y
        geom.applyQuaternion Quaternion.unitVectors Vector.unitZ, normal

        if cfg.pos
            p = vec cfg.pos
            geom.translate p.x, p.y, p.z
            
        geom
        
    #  0000000  000   000  000       0000000  000      000   0000000  00000000  
    # 000        000 000   000      000       000      000  000       000       
    # 000         00000    000      0000000   000      000  000       0000000   
    # 000          000     000           000  000      000  000       000       
    #  0000000     000     0000000  0000000   0000000  000   0000000  00000000  
    
    @cylslice: (cfg) ->
        
        dir    = cfg.dir ? Vector.unitZ
        start  = cfg.start ? Vector.unitX
        radius = cfg.radius ? 1
        length = cfg.length ? 1
        sgmt   = cfg.sgmt ? 8
        
        geom = new CylinderGeometry radius, radius, length, sgmt, 1, true, 0, Math.PI/2
        dirq = Quaternion.unitVectors Vector.unitY, dir
        geom.applyQuaternion dirq
        geom.applyQuaternion Quaternion.unitVectors Vector.unitX.clone().applyQuaternion(dirq), start
        
        if cfg.pos
            p = vec cfg.pos
            geom.translate p.x, p.y, p.z
            
        geom
        
    #  0000000   0000000   00000000   000   000  00000000  00000000   
    # 000       000   000  000   000  0000  000  000       000   000  
    # 000       000   000  0000000    000 0 000  0000000   0000000    
    # 000       000   000  000   000  000  0000  000       000   000  
    #  0000000   0000000   000   000  000   000  00000000  000   000  
    
    @corner: (cfg) ->
        
        rx  = deg2rad cfg.rx ? 0
        ry  = deg2rad cfg.ry ? 0
        rz  = deg2rad cfg.rz ? 0
        radius = cfg.radius ? 1
        sgmt   = cfg.sgmt ? 8
        
        geom = new SphereGeometry radius, sgmt, sgmt, 0, Math.PI/2, 0, Math.PI/2
        geom.rotateX Math.PI/2
        geom.rotateZ Math.PI

        matrix = new THREE.Matrix4
        matrix.makeRotationFromEuler new THREE.Euler rx, ry, rz
        geom.applyMatrix4 matrix
        
        if cfg.pos
            p = vec cfg.pos
            geom.translate p.x, p.y, p.z
            
        geom
        
    # 00000000    0000000   000   000  000   000  0000000    00000000  0000000    0000000     0000000   000   000  
    # 000   000  000   000  000   000  0000  000  000   000  000       000   000  000   000  000   000   000 000   
    # 0000000    000   000  000   000  000 0 000  000   000  0000000   000   000  0000000    000   000    00000    
    # 000   000  000   000  000   000  000  0000  000   000  000       000   000  000   000  000   000   000 000   
    # 000   000   0000000    0000000   000   000  0000000    00000000  0000000    0000000     0000000   000   000  
    
    @roundedBox: (cfg) ->

        cr = cfg.radius ? 0.2
        sz = cfg.size ? vec(cfg.size) : vec 1 1 1
        
        rightside = @quad size:[sz.z-cr*2, sz.y-cr*2], normal:Vector.unitX,  pos:[ sz.x/2, 0, 0]
        leftside  = @quad size:[sz.z-cr*2, sz.y-cr*2], normal:Vector.minusX, pos:[-sz.x/2, 0, 0]
        backside  = @quad size:[sz.x-cr*2, sz.z-cr*2], normal:Vector.minusY, pos:[0, -sz.y/2, 0]
        frontside = @quad size:[sz.x-cr*2, sz.z-cr*2], normal:Vector.unitY,  pos:[0,  sz.y/2, 0]
        topside   = @quad size:[sz.x-cr*2, sz.y-cr*2], normal:Vector.unitZ,  pos:[0, 0,  sz.z/2]
        botside   = @quad size:[sz.x-cr*2, sz.y-cr*2], normal:Vector.minusZ, pos:[0, 0, -sz.z/2]
        sides     = merge topside, rightside, backside, botside, leftside, frontside
        
        botfront   = @cylslice radius:cr, dir:Vector.unitX,  start:Vector.minusZ, length:sz.x-cr*2, pos:[0, -sz.y/2+cr, -sz.z/2+cr]
        botback    = @cylslice radius:cr, dir:Vector.minusX, start:Vector.minusZ, length:sz.x-cr*2, pos:[0,  sz.y/2-cr, -sz.z/2+cr]
        botleft    = @cylslice radius:cr, dir:Vector.minusY, start:Vector.minusZ, length:sz.y-cr*2, pos:[-sz.x/2+cr, 0, -sz.z/2+cr]
        botright   = @cylslice radius:cr, dir:Vector.unitY,  start:Vector.minusZ, length:sz.y-cr*2, pos:[ sz.x/2-cr, 0, -sz.z/2+cr]
                               
        frontleft  = @cylslice radius:cr, dir:Vector.unitZ,  start:Vector.minusY, length:sz.z-cr*2, pos:[-sz.x/2+cr, -sz.y/2+cr, 0]
        backleft   = @cylslice radius:cr, dir:Vector.minusZ, start:Vector.unitY,  length:sz.z-cr*2, pos:[-sz.x/2+cr,  sz.y/2-cr, 0]
        frontright = @cylslice radius:cr, dir:Vector.unitZ,  start:Vector.unitX,  length:sz.z-cr*2, pos:[ sz.x/2-cr, -sz.y/2+cr, 0]
        backright  = @cylslice radius:cr, dir:Vector.minusZ, start:Vector.unitX,  length:sz.z-cr*2, pos:[ sz.x/2-cr,  sz.y/2-cr, 0]
                               
        topfront   = @cylslice radius:cr, dir:Vector.minusX, start:Vector.unitZ,  length:sz.x-cr*2, pos:[0, -sz.y/2+cr, sz.z/2-cr]
        topback    = @cylslice radius:cr, dir:Vector.unitX,  start:Vector.unitZ,  length:sz.x-cr*2, pos:[0,  sz.y/2-cr, sz.z/2-cr]
        topleft    = @cylslice radius:cr, dir:Vector.unitY,  start:Vector.unitZ,  length:sz.y-cr*2, pos:[-sz.x/2+cr, 0, sz.z/2-cr]
        topright   = @cylslice radius:cr, dir:Vector.minusY, start:Vector.unitZ,  length:sz.y-cr*2, pos:[ sz.x/2-cr, 0, sz.z/2-cr]
        
        rft = @corner radius:cr, rx:0, ry:0, rz: 0, pos:[sz.x/2-cr,  sz.y/2-cr, sz.z/2-cr]
        lft = @corner radius:cr, rx:0, ry:0, rz:90, pos:[-sz.x/2+cr, sz.y/2-cr, sz.z/2-cr]

        rfb = @corner radius:cr, rx:0, ry:180, rz:90, pos:[sz.x/2-cr,  sz.y/2-cr, -sz.z/2+cr]
        lfb = @corner radius:cr, rx:0, ry:180, rz:0, pos:[-sz.x/2+cr, sz.y/2-cr, -sz.z/2+cr]

        rbt = @corner radius:cr, rx:0, ry:0, rz:-90, pos:[sz.x/2-cr,  -sz.y/2+cr, sz.z/2-cr]
        lbt = @corner radius:cr, rx:0, ry:0, rz:180, pos:[-sz.x/2+cr, -sz.y/2+cr, sz.z/2-cr]

        rbb = @corner radius:cr, rx:0, ry:180, rz:180, pos:[sz.x/2-cr,  -sz.y/2+cr, -sz.z/2+cr]
        lbb = @corner radius:cr, rx:0, ry:180, rz:-90, pos:[-sz.x/2+cr, -sz.y/2+cr, -sz.z/2+cr]
        
        corns = merge rft, lft, rbt, lbt, rfb, lfb, rbb, lbb 
        frame = merge botfront, botback, botleft, botright, topfront, topback, topleft, topright, frontright, backright, frontleft, backleft
        box = merge frame, corns#, sides
        if cfg.pos
            p = vec cfg.pos
            box.translate p.x, p.y, p.z
        box.computeVertexNormals()
        box.computeBoundingSphere()
        box
        
    #  0000000   0000000   00000000   000   000  00000000  00000000   0000000     0000000   000   000  
    # 000       000   000  000   000  0000  000  000       000   000  000   000  000   000   000 000   
    # 000       000   000  0000000    000 0 000  0000000   0000000    0000000    000   000    00000    
    # 000       000   000  000   000  000  0000  000       000   000  000   000  000   000   000 000   
    #  0000000   0000000   000   000  000   000  00000000  000   000  0000000     0000000   000   000  
    
    @cornerBox: (size=1, x=0, y=0, z=0) ->
                    
        o = size/2
        s = 0.9*o
        i = 0.8*o
        
        topside = new BufferGeometry()
        
        vertices = new Float32Array [
            i,  i, o
            -i,  i, o
            -i, -i, o
            i,  i, o
            -i, -i, o
            i, -i, o
            s,  s, s
            -s,  s, s
            -i,  i, o
            s,  s, s
            -i,  i, o
            i,  i, o
            -s,  s, s
            -s, -s, s
            -i, -i, o
            -s,  s, s
            -i, -i, o
            -i,  i, o
            -s, -s, s
            s, -s, s
            i, -i, o
            -s, -s, s
            i, -i, o
            -i, -i, o
            s,  s, s
            i,  i, o
            i, -i, o
            s,  s, s
            i, -i, o
            s, -s, s
        ]
        
        topside.setAttribute 'position' new BufferAttribute vertices, 3

        rightside = new BufferGeometry()
        rightside.copy topside
        rightside.rotateY deg2rad 90

        leftside = new BufferGeometry()
        leftside.copy topside
        leftside.rotateY deg2rad -90

        backside = new BufferGeometry()
        backside.copy topside
        backside.rotateX deg2rad -90

        frontside = new BufferGeometry()
        frontside.copy topside
        frontside.rotateX deg2rad 90

        bottomside = new BufferGeometry()
        bottomside.copy topside
        bottomside.rotateX deg2rad -180
                
        cube = merge topside, rightside, backside, bottomside, leftside, frontside
        cube.translate x, y, z
        cube.computeVertexNormals()
        cube.computeBoundingSphere()
        cube
        
module.exports = Geometry
