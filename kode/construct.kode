###
 0000000   0000000   000   000   0000000  000000000  00000000   000   000   0000000  000000000
000       000   000  0000  000  000          000     000   000  000   000  000          000   
000       000   000  000 0 000  0000000      000     0000000    000   000  000          000   
000       000   000  000  0000       000     000     000   000  000   000  000          000   
 0000000   0000000   000   000  0000000      000     000   000   0000000    0000000     000   
###

{ CSG } = require '../kode/csg/csg'
        
class Construct

    @: ->
        
        @segmentMesh = [null,null,null,null]
        @stoneMeshes = {}     
        @stoneMaterials = {}
        @meshes = {}
        
        for stone in Stone.all
            @stoneMaterials[stone] = Materials.stone[stone].clone()
            
    # 000  000   000  000  000000000  
    # 000  0000  000  000     000     
    # 000  000 0 000  000     000     
    # 000  000  0000  000     000     
    # 000  000   000  000     000     
    
    init: -> 
        
        @initTrains()
        @initBotGeoms()
        @initStoneSides()
        
    # 000000000  00000000    0000000   000  000   000   0000000  
    #    000     000   000  000   000  000  0000  000  000       
    #    000     0000000    000000000  000  000 0 000  0000000   
    #    000     000   000  000   000  000  000  0000       000  
    #    000     000   000  000   000  000  000   000  0000000   
    
    initTrains: ->
        
        ●▸ trains
         
        subtract  = (a,b) -> CSG.toGeometry CSG.fromGeometry(a).subtract  CSG.fromGeometry b
        intersect = (a,b) -> CSG.toGeometry CSG.fromGeometry(a).intersect CSG.fromGeometry b
        union     = (a,b) -> CSG.toGeometry CSG.fromGeometry(a).union     CSG.fromGeometry b
     
        seg = 16
        sphere   = new THREE.SphereGeometry   1.0 seg, seg
        cylinder = new THREE.CylinderGeometry 1.0 1.0 2.0 seg
        
        rail = new THREE.BoxGeometry 3 2 1
        rail.translate 0 0 -1
        cylinder = subtract cylinder, rail
        
        sphere.translate 0 1 0
        geom = union sphere, cylinder
        sphere.translate 0 -2 0
        pill = union geom, sphere
         
        wind = new THREE.BoxGeometry 1.5 0.5 0.5
        wind.translate 0 -1.6 0.5
        
        side = new THREE.BoxGeometry 2 0.3 0.22
        side.translate 0 -1.05 0.65
        wind = union wind, side
        
        geom = subtract pill, wind

        rail = new THREE.BoxGeometry 1 8 1
        rail.translate 0 0 -1
        geom = subtract geom, rail
        
        # count = geom.attributes.position.count
        @meshes['train'] = new THREE.Mesh geom, Materials.train.body
        @meshes['train'].receiveShadow = true
        @meshes['train'].castShadow = true
        
        geom = intersect pill, wind
        @meshes['train'].add new THREE.Mesh geom, Materials.train.window
                
        ●▪ trains
        
    trains: ->
                        
        for train,index in world.trains
            mesh = @meshes['train'].clone()
            # mesh.bot = bot.type # needed for intersection test
            world.scene.add mesh
            train.mesh = mesh
            world.pickables.push mesh
            @updateTrain train

    updateTrain: (train) ->
        
        if train.mesh
            train.mesh.position.copy train.pos
            train.mesh.translateZ 1
                
# 0000000     0000000   000000000   0000000   00000000   0000000   00     00   0000000  
# 000   000  000   000     000     000        000       000   000  000   000  000       
# 0000000    000   000     000     000  0000  0000000   000   000  000000000  0000000   
# 000   000  000   000     000     000   000  000       000   000  000 0 000       000  
# 0000000     0000000      000      0000000   00000000   0000000   000   000  0000000   

    initBotGeoms: ->
                
        @botGeoms = [
            new THREE.BufferGeometry
            new THREE.BoxGeometry 0.5, 0.5, 0.5            # cube
            new THREE.ConeGeometry 0.25, 0.5, 12           # cone
            new THREE.SphereGeometry 0.25, 12, 12          # sphere
            new THREE.TorusGeometry 0.2, 0.125, 8, 12      # torus
            new THREE.IcosahedronGeometry 0.3, 0           # icosa
            new THREE.DodecahedronGeometry 0.3, 0          # dodeca
            new THREE.TetrahedronGeometry 0.5, 0           # tetra
            new THREE.OctahedronGeometry 0.3, 0            # octa
            new THREE.CylinderGeometry 0.25, 0.25, 0.5, 12 # cylinder
            new THREE.TorusKnotGeometry 0.15, 0.1          # knot
            new THREE.DodecahedronGeometry 0.275, 0        # dodicos
            new THREE.BoxGeometry 0.25, 0.25, 0.25         # octacube
            new THREE.TorusGeometry 0.2, 0.075, 8, 12      # toruscone
        ]
        
        @botGeoms[Geom.dodicos].rotateX deg2rad 60
        icos = new THREE.IcosahedronGeometry 0.275, 0
        icos.rotateY deg2rad 60
        icos.rotateZ deg2rad -18
        @botGeoms[Geom.dodicos] = THREE.BufferGeometryUtils.mergeBufferGeometries [@botGeoms[Geom.dodicos], icos]
                
        cone = new THREE.ConeGeometry 0.25, 0.5, 12
        cone.rotateX deg2rad 90
        @botGeoms[Geom.toruscone] = THREE.BufferGeometryUtils.mergeBufferGeometries [@botGeoms[Geom.toruscone], cone]
                        
        @botGeoms[Geom.octacube] = THREE.BufferGeometryUtils.mergeBufferGeometries [@botGeoms[Geom.octacube], new THREE.OctahedronGeometry 0.25, 0]
        
        knot = new THREE.TorusKnotGeometry 0.1, 0.075
        knot.translate 0,0,-0.175
        @botGeoms[Geom.knot] = THREE.BufferGeometryUtils.mergeBufferGeometries [@botGeoms[Geom.knot], knot]
        
        @botGeoms[Geom.cone].rotateX deg2rad 90
        @botGeoms[Geom.sphere].rotateX deg2rad 90
        @botGeoms[Geom.cylinder].rotateX deg2rad 90
        @botGeoms[Geom.dodeca].rotateX deg2rad 60
        @botGeoms[Geom.icosa].rotateY deg2rad 60
        @botGeoms[Geom.icosa].rotateZ deg2rad 18

    geometryForBot: (bot) ->
        @botGeoms[@geomForBot bot]
    
    geomForBot: (bot) -> @geomForBotType bot.type
        
    geomForBotType: (type) ->
        # log "geomForBotType #{Bot.string type}"
        switch type
            when Bot.base  then Geom.dodicos
            when Bot.mine  then Geom.octacube
            when Bot.build then Geom.cubecross
            when Bot.trade then Geom.toruscone
            when Bot.brain then Geom.knot
            when Bot.berta then Geom.tubecross
    
    # 0000000     0000000   000000000   0000000  
    # 000   000  000   000     000     000       
    # 0000000    000   000     000     0000000   
    # 000   000  000   000     000          000  
    # 0000000     0000000      000     0000000   
    
    bots: ->
                        
        for index,bot of world.bots
            
            @botAtPos bot, world.posAtIndex index
            
    botAtPos: (bot, pos) ->
        
        mesh = new THREE.Mesh @geometryForBot(bot), Materials.bot[Stone.gray]
        mesh.receiveShadow = true
        mesh.castShadow = true
        mesh.position.copy pos
        mesh.bot = bot.type # needed for intersection test
        world.scene.add mesh
        bot.mesh = mesh
        
        @dot bot
        @updateBot bot

    updateBot: (bot) ->
        
        return if not bot.mesh
        bot.mesh.position.copy bot.pos
        bot.highlight?.position.copy bot.pos
        @orientBot bot
        world.colorBot bot
        
    orientFace: (obj, face) -> obj.quaternion.copy Quaternion.unitVectors Vector.unitZ, Vector.normals[face]
    
    orientBot: (bot) -> 
        
        @orientFace bot.mesh, bot.face
        @orientFace bot.dot,  bot.face
        bot.dot.position.copy bot.pos.minus Vector.normals[bot.face].mul 0.35
                    
    # 0000000     0000000   000000000  
    # 000   000  000   000     000     
    # 000   000  000   000     000     
    # 000   000  000   000     000     
    # 0000000     0000000      000     
    
    dot: (bot) ->
                
        sphere = new THREE.SphereGeometry 0.1, 6, 6
        sphere.rotateX deg2rad 90
        
        bot.dot = new THREE.Mesh sphere, Materials.white
        bot.dot.castShadow = true
        bot.dot.receiveShadow = true
        world.scene.add bot.dot
        
    # 000   000  000   0000000   000   000  000      000   0000000   000   000  000000000  
    # 000   000  000  000        000   000  000      000  000        000   000     000     
    # 000000000  000  000  0000  000000000  000      000  000  0000  000000000     000     
    # 000   000  000  000   000  000   000  000      000  000   000  000   000     000     
    # 000   000  000   0000000   000   000  0000000  000   0000000   000   000     000     
    
    highlight: (bot) ->
        # log 'highlight'
        if bot.type != Bot.icon
            geom = @geometryForBot bot
        else
            geom = Geometry.box 0.5
        s = 1.05
        geom.scale s,s,s
        
        mesh = new THREE.Mesh geom, Materials.highlight
        mesh.position.copy bot.pos
        @orientFace mesh, bot.face
        world.scene.add mesh
        mesh
                    
    #  0000000  000000000   0000000   000   000  00000000   0000000    
    # 000          000     000   000  0000  000  000       000         
    # 0000000      000     000   000  000 0 000  0000000   0000000     
    #      000     000     000   000  000  0000  000            000    
    # 0000000      000      0000000   000   000  00000000  0000000     
    
    initStoneSides: ->

        s = 0.5
        o = 0.55
        i = 0.45
        
        @topside = new THREE.BufferGeometry()
        
        vertices = new Float32Array([
            i,  i, o,
            -i,  i, o,
            -i, -i, o,
            i,  i, o,
            -i, -i, o,
            i, -i, o,
            s,  s, s,
            -s,  s, s,
            -i,  i, o,
            s,  s, s,
            -i,  i, o,
            i,  i, o,
            -s,  s, s,
            -s, -s, s,
            -i, -i, o,
            -s,  s, s,
            -i, -i, o,
            -i,  i, o,
            -s, -s, s,
            s, -s, s,
            i, -i, o,
            -s, -s, s,
            i, -i, o,
            -i, -i, o,
            s,  s, s,
            i,  i, o,
            i, -i, o,
            s,  s, s,
            i, -i, o,
            s, -s, s
            ])
        
        @topside.setAttribute 'position' new THREE.BufferAttribute vertices, 3
        
        @rightside = new THREE.BufferGeometry()
        @rightside.copy @topside
        @rightside.rotateY deg2rad 90
        
        @leftside = new THREE.BufferGeometry()
        @leftside.copy @topside
        @leftside.rotateY deg2rad -90

        @backside = new THREE.BufferGeometry()
        @backside.copy @topside
        @backside.rotateX deg2rad -90

        @frontside = new THREE.BufferGeometry()
        @frontside.copy @topside
        @frontside.rotateX deg2rad 90

        @bottomside = new THREE.BufferGeometry()
        @bottomside.copy @topside
        @bottomside.rotateX deg2rad -180
        
    stones: ->
        
        stonesides = []
        for stone in Stone.all
            stonesides.push []
        
        for index,stone of world.stones
            p = world.posAtIndex index
            sides = []
            if not world.isStoneAt p.x, p.y, p.z+1 then sides.push @topside
            if not world.isStoneAt p.x+1, p.y, p.z then sides.push @rightside
            if not world.isStoneAt p.x, p.y+1, p.z then sides.push @backside
            if not world.isStoneAt p.x, p.y, p.z-1 then sides.push @bottomside
            if not world.isStoneAt p.x-1, p.y, p.z then sides.push @leftside
            if not world.isStoneAt p.x, p.y-1, p.z then sides.push @frontside
            if sides.length
                cube = THREE.BufferGeometryUtils.mergeBufferGeometries sides
                cube.translate p.x, p.y, p.z
                stonesides[stone].push cube
            
        for stone in Stone.all
            
            if @stoneMeshes[stone]
                @stoneMeshes[stone].parent.remove @stoneMeshes[stone]
                
            if stonesides[stone].length
                bufgeo = THREE.BufferGeometryUtils.mergeBufferGeometries stonesides[stone]
                bufgeo.computeVertexNormals()
                mesh = new THREE.Mesh bufgeo, @stoneMaterials[stone]
                mesh.receiveShadow = true
                mesh.castShadow = true
                mesh.stone = stone
                world.scene.add mesh            
                @stoneMeshes[stone] = mesh

module.exports = Construct
